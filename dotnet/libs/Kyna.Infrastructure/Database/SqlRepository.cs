using System.Text;

namespace Kyna.Infrastructure.Database;

/// <summary>
/// Represents an internal repository of all available SQL statements for
/// all available db engines.
/// </summary>
internal static partial class SqlRepository
{
    private static readonly Dictionary<SqlRepoKey, string> _sqlDictionary = new(100);

    static SqlRepository()
    {
        foreach (var kvp in GetApiTransactionSql()
            .Union(GetLoggingSql())
            .Union(GetEodPriceSql())
            .Union(GetAdjustedEodPriceSql())
            .Union(GetRemoteFileSql())
            .Union(GetSplitsSql())
            .Union(GetDividendsSql())
            .Union(GetFundamentalsSql())
            .Union(GetBacktestSql())
            .Union(GetStatsSql())
            .Union(GetMigrationsSql()))
        {
            _ = _sqlDictionary.TryAdd(kvp.Key, kvp.Value);
        }
    }

    /// <summary>
    /// Construct a new dictionary with the SQL statements for the specified engine.
    /// </summary>
    /// <param name="dbEngine">The db engine by which to filter SQL statements.</param>
    /// <param name="allowMissingKeys">If true, the dictionary does not have to complete.
    /// <returns>A dictionary of all avaliable SQL statements for a given engine, indexed
    /// by a unique key. See <see cref="SqlKeys"/>.</returns>
    /// <exception cref="Exception">Thrown if <paramref name="allowMissingKeys"/> is false
    /// and the constructed dictionary is missing one or more keys, as defined by the
    /// <see cref="SqlKeys"/> class.</exception>
    public static IDictionary<string, string> BuildDictionary(DatabaseEngine dbEngine,
        bool allowMissingKeys = false)
    {
        var results = _sqlDictionary.Where(d => d.Key.DbEngine.Equals(dbEngine))
            .Select(k => new KeyValuePair<string, string>(k.Key.SqlStatementKey, k.Value)).ToDictionary();

        if (!allowMissingKeys)
        {
            var missingKeys = SqlKeys.GetKeys().Except(results.Keys).ToArray();

            if (missingKeys.Length > 0)
            {
                var sb = new StringBuilder();
                sb.Append(nameof(SqlRepository));
                sb.Append('.');
                sb.Append(nameof(BuildDictionary));
                sb.Append($" missing keys for: {string.Join(", ", missingKeys)}");
                throw new Exception(sb.ToString());
            }
        }

        return results;
    }
}

/// <summary>
/// Repesents an internal key for items in the Sql Dictionary generated by the
/// <see cref="SqlRepository.BuildDictionary"/> method.
/// </summary>
internal readonly struct SqlRepoKey(string sqlStatementKey, DatabaseEngine dbEngine = DatabaseEngine.PostgreSql)
{

    /// <summary>
    /// Gets the database engine to which the SQL statement is expected to be applied.
    /// </summary>
    public DatabaseEngine DbEngine { get; init; } = dbEngine;

    /// <summary>
    /// Gets the key for the statement; this is typically a constant.
    /// <seealso cref="SqlKeys"/>.
    /// </summary>
    public string SqlStatementKey { get; init; } = sqlStatementKey ?? throw new ArgumentNullException(nameof(sqlStatementKey));
}